<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UFT-8">
	<title></title>
</head>
<body>
	<h1>指针</h1>
	<hr>
	<h2>基本介绍</h2>
	<p>1.定义指针变量用类型名 *标识符，例如int *i_pointer，在定义指针变量时必须指定基类型。</p>
	<p>2.赋变量操作：i_pointer=&i</p>
	<p>3.赋值操作：*i_pointer=3</p>
	<p>指针就是地址，可以说变量i的指针是2000，而不能说i的指针变量是2000.指针是一个地址，而指针变量是存放地址的变量。</p>
	<p>指针变量作为函数参数相当于按地址传递。可以返回多个值。</p>
	<h2>通过指针引用数组</h2>
	<hr>
	<p>这两个语句等价：p=&a[0]与p=a</p>
	<p>在定义指针变量时可以对它初始化，如:int *p=&a[0];它等效于：int *p;p=&a[0]，当然定义时也可以写成 int *p=a;</p>
	<p>在一定条件下允许对指针进行加和减的操作，对引用数组元素提供很大的方便。支持加减一个整数，自加自减运算，两个指针相减(求出中间有多少个元素)。两个指针相加没有实际意义的。</p>
	<p>通过指针引用数组用*(a+i)</p>
	<p>程序编译时是将数组按指针变量处理的，相当于把数组名写成指针。</p>
	<h2>通过指针引用多维数组</h2>
	<hr>
	<p>从二维数组的角度来看，a代表二维数组首元素的地址，但其单位长度是一个数组的长度，因此必须定义第二维数组长度的意义在此。</p>
	<p>可以将数组名直接当做指针使用，执行运算操作。</p>
	<p>&a[0][0]=a[0],这些代表第一个元素的地址。代表*a[0]则代表二维数组第一个元素了。那么，a[0]+1(a[1][0])代表第二个元素地址，*(a[0]+1)代表第二个元素。</p>
	<p>*a=a[0]=&a[0][0],注意，这只是它的值是一样的，都是第一个元素的地址，但是它们的性质是不一样的。这时我们就会知道，a[0]=*a[0]</p>
	<p>总结：</p>
	<p>a+i==*(a+i)</p>
	<p>*(a+i)+j==a[i]+j==&a[i][j]</p>
	<p>*(*(a+i)+j)==*(a[i]+j)=a[i][j]</p>
	<p>对指针数组的定义：int (*a)[4],因为指针符号的优先级比数组优先级要小，因此int *a[4]就是定义指针数组，而int (*a)[4]表示定义一个指针变量a,它指向包含4个整型元素的一维数组。a的值就是该一维数组的首地址</p>
	<p>定义字符型指针变量时，可以将其赋值为一个字符串常量，例如：char *string="I love China!",而且随时可以将其转向一个字符串常量，例如：string="I love C!"</p>
	<p>指向函数的指针：int (*p)(int int)，因为在编译时，编译系统为函数代码分配一段存储空间，这段存储空间的起始地址成为这个函数的指针。然后使用时直接用这个指针对准函数名即可。用的时候应该用（*p）(参数)代替函数。</p>
	<p>指向函数的指针变量的一个重要用途就是把函数的地址作为参数传递到其他参数。举例：void fun(int (*x1)(int),int (*x2)(int,int))用的时候就用好了</p>
	<p>返回指针的函数：类型名 *函数名（参数列表），因此，必须将其指向作为参数的指针才行。</p>
	<p>指向指针的指针的定义：char **p;就这样。从理论上说，间址方法可以延伸到更多的级，即多重指针。但实际上在程序中很少超过二级间址的。</p>
	<p>可以定义一个基类型为void的指针变量，它不指向任何类型的数据，且不能指向任何类型的数据，它在对别的指针赋值时，系统会对它进行类型转换，就这样让这个指针的值赋出去。</p>
</body>
</html>