# 哈希表
---
+ 设计一个好的哈希函数
+ 设计一种能有效处理冲突的方法
  ## 常用哈希函数构造法
  1. ### 直接地址法
    取关键字或它的某个线性函数值为哈希地址，就是线性函数，简单，均匀，不会产生冲突，但实际不常用
  + ### 数字分析法
    预先都知道关键字，则可以关键字的若干数位组成哈希地址
  + ### 平方取中法
    先求关键字的平方 ，在根据表长取出中间几位作为哈希地址，适用于关键字分布未知，且关键字的个数不是很多
  + ### 折叠法
    将关键字分割成位数相同的几部分，（最后一部分的可以不相同），然后取出这几部分的叠加和（舍去进位）作为哈希地址），适用于关键字位数很多，且关键字每位上的数字分布大致均匀的情况
  + ### 基数转换法
    先把关键字看成基数为r
    1的数，然后将它转换成基数为r2的数，再选取其中几位作为哈希地址
  + ### 除数留余法
    选择某个不大于表长的数p，取关键字后除以p以后所得到的余数为哈希地址，可以直接取模，也可以折叠，平方之后取模，p应当选取质数，否则关键字被映射到0-p-1范围内的均匀度将大幅降低，发生冲突的概率随着p所含质因子的增多而迅速增大
  + ### 伪随机数法
    选择一个随机函数，取关键字的随机函数值为其哈希地址，对，是C语言为随机函数的性质决定的，通常当关键字的长度不等的时候，采用此法较恰当，不能用于两个语言系统
## 处理冲突
### 闭散列方法/开放地址法
对于处理冲突而言，它的目的仅仅是为了把数据插进去，ASLs为成功时的平均查找长度，表中平均查找次数（冲突次数+1）
不成功时的平均查找长度ASLu，不在表中的关键字（按地址分类）的平均查找次数
+ 线性探测再散列
  处理冲突的过程中可能得到一个地址序列：Hi = (H(key)+di)mod m,其中，i表示不成功后的增量，所以说，只是插进去完事
  ## 开放地址法-线性探测再散列
  + 线性探测再散列：
     + 缺点是冲突加剧，最坏的时候可能达到o(n)的代价
     + 优点是只要哈希表未满，总能找到一个不发生冲突的地址。
  H(key)=(key+2)mod11貌似是一个十分重要的函数
  + 二次探测再散列
     + 不怎么会了
  + 双散列探测法
    + 用另一个hashing函数作为步长进行探测
  + 再哈希法
在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生，不易产生聚焦，但增加了计算的时间
+ 链地址法
将所有的哈希地址为i的记录存储在同一条线性表（同义词链），并将链表的头指针存储在哈希表的第i个单元中。
+ 公共溢出区法
若哈希函数的值域为[0, m-1],则设一个同等大小的基本表，另设一个溢出表，但凡与基本表发生冲突的记录，一律填入溢出表
# 因此
 