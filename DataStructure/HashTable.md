# 哈希表
---
+ 设计一个好的哈希函数
+ 设计一种能有效处理冲突的方法
  ## 常用哈希函数构造法
  + ### 直接地址法
    取关键字或它的某个线性函数值为哈希地址，就是线性函数，简单，均匀，不会产生冲突，但实际不常用
  + ### 数字分析法
    预先都知道关键字，则可以关键字的若干数位组成哈希地址
  + ### 平方取中法
    先求关键字的平方 ，在根据表长取出中间几位作为哈希地址，适用于关键字分布未知，且关键字的个数不是很多
  + ### 折叠法
    将关键字分割成位数相同的几部分，（最后一部分的可以不相同），然后取出这几部分的叠加和（舍去进位）作为哈希地址），适用于关键字位数很多，且关键字每位上的数字分布大致均匀的情况
  + ### 基数转换法
    先把关键字看成基数为r
    1的数，然后将它转换成基数为r2的数，再选取其中几位作为哈希地址
  + ### 除数留余法
    选择某个不大于表长的数p，取关键字后除以p以后所得到的余数为哈希地址，可以直接取模，也可以折叠，平方之后取模，p应当选取质数，否则关键字被映射到0-p-1范围内的均匀度将大幅降低，发生冲突的概率随着p所含质因子的增多而迅速增大
  + ### 伪随机数法
    选择一个随机函数，取关键字的随机函数值为其哈希地址，对，是C语言为随机函数的性质决定的，通常当关键字的长度不等的时候，采用此法较恰当，不能用于两个语言系统
## 处理冲突
### 闭散列方法/开放定址法和开散列方法/封闭定址法
### 闭散列方法/开放地址法
对于处理冲突而言，它的目的仅仅是为了把数据插进去，ASLs为成功时的平均查找长度，表中平均查找次数（冲突次数+1）
不成功时的平均查找长度ASLu，不在表中的关键字（按地址分类）的平均查找次数
状态因子a为为关键字个数除以表长
+ 线性探测再散列
  处理冲突的过程中可能得到一个地址序列：Hi = (H(key)+di)mod m,其中，i表示不成功后的增量，所以说，只是插进去完事，di取1，2，3，4，5，6什么的就足够了啊。。改进就是改变步长，或者说是二次探查再散列，实质上是把步长改成-1，1，-2, 2 1^2, 2^2, 3^2就是这样，或者说，线性探测再散列就是用+——1，+——2，二次探查再散列就是加上平方正负， 但只有在哈希表长m为素数的时候才可能解决问题？有聚焦问题严重的问题，线性探测就是逐个检查冲突位置的下一个位置，就是这样
  ## 开放地址法-线性探测再散列
  + 线性探测再散列：
     + 缺点是冲突加剧，最坏的时候可能达到o(n)的代价
     + 优点是只要哈希表未满，总能找到一个不发生冲突的地址。
     + 一般来说，只是加一个1表示散列表的位置
     + 除余后的那个就是地址，如果被占用了就加1再进行判断
  H(key)=(key+2)mod11貌似是一个十分重要的函数
  + 二次探测再散列
     + 第二个散列函数要仔细选择，需要满足条件： 1.排除散列值为0的情况 2.产生的散列值必须与表长M互素
     + 其实就是把di换成了di*h（2）就是这样了
  + 双散列探测法
    + 用另一个hashing函数作为步长进行探测
  + 再哈希法
在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生，不易产生聚焦，但增加了计算的时间，也就是说，采用了许多不同的哈希函数，但是，这个是真的能有漏洞
+ 链地址法
将所有的哈希地址为i的记录存储在同一条线性表（同义词链），并将链表的头指针存储在哈希表的第i个单元中。
+ 公共溢出区法
若哈希函数的值域为[0, m-1],则设一个同等大小的基本表，另设一个溢出表，但凡与基本表发生冲突的记录，一律填入溢出表
# 因此
 