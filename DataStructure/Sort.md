
# 冒泡排序
>比较相邻的元素，那么到达最后的那一个元素就是最大或者最小的元素，就这样比较直到没有元素

代码为：
```
for(int i=L.Length; i>0; i--){
    for(int j=1; j<i; j++){
        if(L.elem[j] > L.elem[j+1]){
            int t = L.elem[j];
            L.elem[j] = L.elem[j+1];
            L.elem[j+1] = t;
        }
```
# 选择排序
>每次遍历一遍，将最大值或最小值遍历出来，然后顺序排好，就是这样，实际上，就是你最常用的那种排序，也不是，它记下了最小值的坐标，因此只交换一次而已
# 直接插入排序
>是稳定排序，每次拿出上一个，纳入哨兵中，会有记录后移
>更好的方式是折半查询，但如果有重复的，需要进行相等判断，把相等和大于的合并

>2-路插入排序，将一个中位数当作标志，前后插，空间复杂度增大，时间复杂度也只是/2而已
# 表插入排序
>最重要的是排好序的链表转换成顺序表，关键是保持交换后链表不中断的方法，能够一直找到后继，然后进行交换
# 希尔排序
>大概知道什么意思了
# 堆排序
>首先要会创建最小堆，堆排序实际上就是创建最小堆的过程，堆排序是不稳定的，不是大顶堆，之前做过，现在忘了， 先构造一个大顶堆，然后将这个大顶堆变换成一个有序序列，就是这样，分成两个函数
# 表排序
>又称间接排序，排序时不调整元素的实际位置，而是定义一个额外的数组作为“表”（table）。根据元素的关键字大小来调整元素对应下标在表中的位置。表排序在调整下标的位置时可以使用其他的排序算法，例如直接插入排序。然后进行堆的缩小，同时满足堆的定义