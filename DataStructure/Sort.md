@[TOC](看来不支持自定义目录标题)
# 冒泡排序
>比较相邻的元素，那么到达最后的那一个元素就是最大或者最小的元素，就这样比较直到没有元素，或者称为石头排序，向下排序

*[冒泡排序]:看来也不支持注释

代码为：
```
for(int i=L.Length; i>0; i--){
    for(int j=1; j<i; j++){
        if(L.elem[j] > L.elem[j+1]){
            int t = L.elem[j];
            L.elem[j] = L.elem[j+1];
            L.elem[j+1] = t;
        }
```
# 直接插入排序
>是稳定排序，每次拿出上一个，纳入哨兵中，会有记录后移
>更好的方式是折半查询，但如果有重复的，需要进行相等判断，把相等和大于的合并
>插入排序改的是已经排好的列表，是随便从未插入的混乱列表中随机选取的
>所以插入排序可以用二分法进行排序，而普通排序则不能
>2-路插入排序，将一个中位数当作标志，前后插，空间复杂度增大，时间复杂度也只是/2而已

做法是对于每个从第二个元素开始，在已排好序列中进行二分查找，然后进行元素移动，最后插入
# 表插入排序
>最重要的是排好序的链表转换成顺序表，关键是保持交换后链表不中断的方法，能够一直找到后继，然后进行交换
# 希尔排序 
>是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。第一个缩小增量的排序，理解成缩小增量的插入排序，偶偶希尔排序不是简单粗暴的分成两块，而是那种分隔的那种插入，首先步长挺大的，然后逐渐缩小到1，步长怎么选有讲究，但是一般开始选1/2的那种，最后一定要做一趟步长为1的直接插入

做法是用两个函数，总函数是确定步长，小函数是一个简单插入，是简单插入的加上步长而已
# 堆排序
>首先要会创建最小堆，堆排序实际上就是创建最小堆的过程，堆排序是不稳定的，不是大顶堆，之前做过，现在忘了， 先构造一个大顶堆，然后将这个大顶堆变换成一个有序序列，就是这样，分成两个函数
# 表排序
>又称间接排序，排序时不调整元素的实际位置，而是定义一个额外的数组作为“表”（table）。根据元素的关键字大小来调整元素对应下标在表中的位置。表排序在调整下标的位置时可以使用其他的排序算法，例如直接插入排序。然后进行堆的缩小，同时满足堆的定义
>完全二叉树通常选择采用顺序存储结构的方式，但关键是，二叉树是如何存进去的呢？其实就是按照层序输入的，那么第一个元素就是根元素每一个元素的父节点就是它位置的一半，但应该从0开始不是吗？不，实践证明从1开始，如果从0开始呢？就错位了，不能运行的那种，一般升序采用大顶堆，降序采用小顶堆
```
void HeapSort( HeapType  H) { 
  int i; KeyType rc;
  for(i=H.Length/2; i>0; i--) {
      //是所有中间节点调整一遍，因为这个堆排序只能排一个链
      HeapAdjust(H, i, H.Length);
   }
  for(i=H.Length;i>1;i--) {
      rc=H.elem[1];
      H.elem[1]=H.elem[i]; 
      H.elem[i]=rc;
      //因为根会被每一条链遍历到，所以可行
      HeapAdjust(H, 1, i-1); 
   }
 }
void HeapAdjust(HeapType H, int s, int m){
    int node = s;
    int child = node*2;
    while (child <= m) {
        if (child+1<=m && H.elem[child]<H.elem[child+1])
            child += 1;
        if (H.elem[node] > H.elem[child]) 
            return;
        else { 
            int t = H.elem[node];
            H.elem[node] = H.elem[child];
            H.elem[child] = t;
            node = child;
            child = node*2;
        }
    }
}
```
# 归并排序
>时间复杂度比较小，是稳定排序，进行拆散，然后合并的时候进行队伍排序，从小的往回来的时候进行排序
# 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法
不稳定的排序算法有：快、希、选、堆。冒，归，插，基是稳定排序,如果有步长大于1的一定是不稳定排序，on2一般都是稳定的，nlogn一般都是不稳定的

|---------------+---------------|
|               |               |
|---------------+---------------|
# 快速排序
>快速排序是对冒泡排序的一种改进。步长叫pivot
快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。但也不见得与冒泡排序有什么一样的地方，可能有递归，并不是很简单，从右往左找到小的，插入到左边，用字表的第一个元素作为哨兵之类的

问题是不能有顺序，最杂乱就好了,那么取中间，前端，后端的元素进行比较一下，取中就会是一个改进，空间复杂度是先割小的，那么会减少一倍复杂度。。。

首先要找到一个切入点，一般是第一个，然后找到所有的小于这个切入点的数据插到左边，然后就可以进行递归操作,而且插入排序有相当好的性能，理解成缩小增量的冒泡排序

# 基数排序
>某些时候，基数排序的效率还是蛮高的,比较有意思的一种算法，通过排列从个位到十位以至于到最高位的数字，进行排序，不是稳定排序

# 选择排序
>每次遍历一遍，将最大值或最小值遍历出来，然后顺序排好，就是这样，实际上，不是你常用的那一个，这个是稳定排序，关键就在于找到相同的数据后插入到后面，是这样没错了，这个才是你喜欢的那种排序,额，我喜欢哪个排序来着？好像就是这个吧。。

# 树形选择排序
>所有的叶节点是所有元素，然后赢了进行上一层，一直到根节点，而且位子需要作废，然后重新选冠军,对n个关键字进行两两排序，然后再进行两两比较，如此重复直到选出最小关键字的记录为止，但堆排序对各个地方都比这个好，所以它就被掩盖住了，它是稳定排序

# 堆排序
>首先怎么办才能构建堆？它是从0开始的一维数组，然后要从第一个非叶节点开始（也可以从开头进行开始啊，复杂度没那么简单而已），到最后一个节点结束，如何将堆转换成序列，就是这样，只有非叶子节点不满足堆定义，堆定义是父节点大于两个子节点，去交换，HeapAdjust一次只调整一列，进行往下走。。。不怎么明白了，最后一步是直接交换，然后是相同的调整，就是这样

# 多关键字排序

# 插入排序包括简单插入排序，折半插入排序，2-路插入排序，表插入，希尔排序，希尔排序是那种间隔的，它是用了插入排序的方法了，交换排序包括气泡排序和快速排序，快速排序是那种，上面讲的够详细，选择排序包括简单选择排序，树形排序和堆排序