
# 冒泡排序
>比较相邻的元素，那么到达最后的那一个元素就是最大或者最小的元素，就这样比较直到没有元素

代码为：
```
for(int i=L.Length; i>0; i--){
    for(int j=1; j<i; j++){
        if(L.elem[j] > L.elem[j+1]){
            int t = L.elem[j];
            L.elem[j] = L.elem[j+1];
            L.elem[j+1] = t;
        }
```
# 选择排序
>每次遍历一遍，将最大值或最小值遍历出来，然后顺序排好，就是这样，实际上，就是你最常用的那种排序，也不是，它记下了最小值的坐标，因此只交换一次而已
# 直接插入排序
>是稳定排序，每次拿出上一个，纳入哨兵中，会有记录后移
>更好的方式是折半查询，但如果有重复的，需要进行相等判断，把相等和大于的合并

>2-路插入排序，将一个中位数当作标志，前后插，空间复杂度增大，时间复杂度也只是/2而已
# 表插入排序
>最重要的是排好序的链表转换成顺序表，关键是保持交换后链表不中断的方法，能够一直找到后继，然后进行交换
# 希尔排序
>大概知道什么意思了
# 堆排序
>首先要会创建最小堆，堆排序实际上就是创建最小堆的过程，堆排序是不稳定的，不是大顶堆，之前做过，现在忘了， 先构造一个大顶堆，然后将这个大顶堆变换成一个有序序列，就是这样，分成两个函数
# 表排序
>又称间接排序，排序时不调整元素的实际位置，而是定义一个额外的数组作为“表”（table）。根据元素的关键字大小来调整元素对应下标在表中的位置。表排序在调整下标的位置时可以使用其他的排序算法，例如直接插入排序。然后进行堆的缩小，同时满足堆的定义
>完全二叉树通常选择采用顺序存储结构的方式，但关键是，二叉树是如何存进去的呢？其实就是按照层序输入的，那么第一个元素就是根元素每一个元素的父节点就是它位置的一半，但应该从0开始不是吗？不，实践证明从1开始，如果从0开始呢？就错位了，不能运行的那种，一般升序采用大顶堆，降序采用小顶堆
```
void HeapSort( HeapType  H) { 
  int i; KeyType rc;
  for(i=H.Length/2; i>0; i--) {
      //是所有中间节点调整一遍，因为这个堆排序只能排一个链
      HeapAdjust(H, i, H.Length);
   }
  for(i=H.Length;i>1;i--) {
      rc=H.elem[1];
      H.elem[1]=H.elem[i]; 
      H.elem[i]=rc;
      //因为根会被每一条链遍历到，所以可行
      HeapAdjust(H, 1, i-1); 
   }
 }
void HeapAdjust(HeapType H, int s, int m){
    int node = s;
    int child = node*2;
    while (child <= m) {
        if (child+1<=m && H.elem[child]<H.elem[child+1])
            child += 1;
        if (H.elem[node] > H.elem[child]) 
            return;
        else { 
            int t = H.elem[node];
            H.elem[node] = H.elem[child];
            H.elem[child] = t;
            node = child;
            child = node*2;
        }
    }
}
```